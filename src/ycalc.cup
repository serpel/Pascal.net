


   

import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
    
  
    public void report_error(String message, Object info) {
   
       
        StringBuffer m = new StringBuffer("Error");
   
       
        if (info instanceof java_cup.runtime.Symbol) {
           
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
           
            if (s.left >= 0) {                
               
                m.append(" in line "+(s.left+1));   
               
                if (s.right >= 0)                    
                    
                    m.append(", column "+(s.right+1));
            }
        }
   
       
        m.append(" : "+message);
   
      
        System.err.println(m);
    }
   
  
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};
   


terminal          SEMICOLON, COLON, SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD, LBRACKET, RBRACKET, LPAR, RPAR, GREATER_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, EQUAL, NOT_EQUAL, DOT, ASSIGN;
terminal          PROGRAM, FUNCTION, VAR, CASE, IF, ELSE, WHILE, FOR, REPEAT, THEN, TO, DO, OF, UNTIL, BEGIN, END, AND, OR, REF, WRITELN, READLN;
terminal          ARRAY, STRING, INT, BOOL, TYPE, CONST, NOT, FLOAT, VOID, CHAR, RECORD;

//Types
terminal int     INT_LITERAL;
terminal String  ID;
terminal String  STRING_LITERAL;
terminal boolean BOOLEAN_LITERAL;
terminal float   FLOAT_LITERAL;
terminal char    CHAR_LITERAL;

   

/* 
-------------------------------------
non terminal productions principales
-------------------------------------
*/

non terminal Object program;
non terminal Object block;
non terminal Object decl_seq;
non terminal Object parameter;
non terminal Object statement;
non terminal Object expr;
non terminal Object factor;
non terminal Object term;
non terminal Object constant;
non terminal Object type;
non terminal Object compound;
non terminal Object case_list;
non terminal Object case;
non terminal Object caselabel;
non terminal Object addition;
non terminal Object literal;
non terminal Object stms; 
non terminal Object functions;
non terminal Object function;
non terminal Object const_list;
non terminal Object const_decl;
non terminal Object type_list;
non terminal Object type_decl;
non terminal Object type_body;
non terminal Object var_decl;
non terminal Object decl_param;
non terminal Object decl_list;
non terminal Object params;
non terminal Object param;
non terminal Object ids;
non terminal Object expr_list;
non terminal Object function_call;
non terminal Object accesor_list;
non terminal Object variable;

/* BEGIN */

program   ::= PROGRAM ID parameter SEMICOLON block DOT
              |
              ;
                       
block     ::= decl_seq compound
              ;

decl_seq  ::= constant type_decl var_decl functions               
              ;

//----------------------------
constant  ::= CONST const_list
              | 
              ;

type_decl ::= TYPE type_list
              |
              ;

var_decl  ::= VAR decl_list 
              |
              ;

//------------------------------

const_list::= const_list const_decl
              |
              const_decl
              ;

const_decl::= ID EQUAL literal SEMICOLON
              ;


functions ::= function functions
              |
              ;

function  ::= FUNCTION ID parameter COLON type SEMICOLON compound SEMICOLON
              ;
 
type_list ::= type_list type_body 
              |
              type_body 
              ;
      
type_body ::= ID EQUAL type SEMICOLON
              ;

parameter ::= LPAR params RPAR
              |
              ;

params    ::= params SEMICOLON param
              |
              param
              ; 

param     ::= REF VAR ids COLON type
              |
              VAR ids COLON type
              |
              ids
              ;

ids       ::= ID SEMI ids 
              |
              ID
              ;

stms      ::= stms statement   
              |
              statement             
              ;

statement ::= function_call SEMICOLON
              |
              variable ASSIGN expr SEMICOLON /* ARRAY ASSIGN OR ID ASSIGN*/
              |
              IF expr THEN compound ELSE compound 
              |
              IF expr THEN compound 
              |
              CASE expr OF 
                 case_list
              END
              |
              WHILE expr DO compound 
              |
              FOR ID ASSIGN expr TO expr DO compound
              |
              REPEAT compound UNTIL expr  SEMICOLON     
              |
              WRITELN LPAR expr RPAR SEMICOLON 
              |
              READLN LPAR ID RPAR SEMICOLON 
              ;

case_list ::= case_list case
              |
              case
              ;

case      ::= caselabel COLON compound 
              ;

caselabel ::= caselabel SEMI expr
              |
              expr
              ;

compound  ::= BEGIN stms END
              ;

expr      ::= addition GREATER_THAN_OR_EQUAL addition
              |
              addition GREATER_THAN addition
              |
              addition LESS_THAN addition
              |
              addition LESS_THAN_OR_EQUAL addition
              |
              addition EQUAL addition
              |
              addition NOT_EQUAL addition
              |
              addition
              ;

addition  ::= addition PLUS factor
              |
              addition MINUS factor
              |
              addition OR factor
              | 
              factor
              ;

factor    ::= factor TIMES term
              |
              factor DIVIDE term
              |              
              factor MOD term
              |
              factor AND term
              |
              term
              ;

term      ::= literal
              | 
              NOT term
              | 
              LPAR expr RPAR  /* ((4+3)*5) */
              | 
              function_call
              |
              variable
              ;

literal   ::= STRING_LITERAL
              | 
              BOOLEAN_LITERAL
              | 
              FLOAT_LITERAL
              |
              CHAR_LITERAL
              | 
              INT_LITERAL 
              ;

function_call ::= ID LPAR expr_list RPAR
              ;
         
variable      ::= ID accesor_list    
              ;

accesor_list ::= 
              DOT ID accesor_list 
              |
              LBRACKET expr_list RBRACKET accesor_list
              |
              ;

expr_list     ::= expr_list SEMI expr
              | 
              expr
              ;

type          ::= ARRAY LBRACKET expr_list RBRACKET OF type
              |
              RECORD decl_list END
              |
              STRING
              |
              CHAR
              |
              FLOAT
              |
              INT
              |
              BOOL
              |
              ID
              |
              VOID 
              ;

decl_param    ::= ids COLON type SEMICOLON
              ;

decl_list     ::= 
              decl_list decl_param
              |
              decl_param
              ;
